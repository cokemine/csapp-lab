# DataLab

## bitXor

只使用取反、按位与操作实现异或运算

解：根据德摩根律
$$
x \oplus y = \neg xy \vee \neg yx
= \neg (\neg(\neg xy) \land \neg(\neg yx))
$$

## tmin

返回用二进制补码表示的最小的整数

补码最高位为符号位，int 类型为 4 字节 32 位，把 1 左移 31 位即可得到

## isTmax

判断 x 是不是二进制补码表示下最大的整数

二进制补码表示最小的整数可以通过将 1 左移 31 位得到 100000.....0，二进制补码最大整数应该为 011111.....1，两者异或得 111111.....1，按位取反为 0

我一开始是这么想的，但是发现不能用移位操作符。

实际上考虑 011111.....1 + 1= 100000.....0 就得到二进制补码的最小整数了。

得到结论，若 x 为二进制补码表示下的最大整数，则有 `(~(x + 1) ^ x) == 0`

但是这仅是一个充分不必要条件。

对 -1 执行 +1 的操作会发生溢位，导致溢位后的 000000.....0 ^ 111111.....1 = 111111.....1 结果仍满足按位取反为 0，需要单独判断。

因此需要满足两个条件 `!(~(x + 1) ^ x)) == 1`  且 `!!(x + 1) == 1`

## allOddBits

判断二进制表示下的 x 是否所有奇数位均为 1

类似于计算机网络中子网掩码的处理方式。构造一个 32 位掩码，奇数位为 1，偶数位为 0，即 0xAAAAAAAA

显然 x 与 0xAAAAAAAA 做与运算会得到这个数的所有奇数位，偶数位会被忽略（即为 0）。再与这个掩码做按位异或运算，如果为 0 说明所有奇数位为 1 否则肯定有一位的奇数位为 0 不符合条件。

## negate

计算机组成原理的基本知识。求补码的相反数：按位取反再加一

## isAsciiDigit

判断所给的 x 是否满足：0x30 <= x <= 0x39，即 x 是不是 ASCII 码下的 '0' - '9'

分析 ASCII 码所表示的  '0' '9' 的关系

0x30: *0011 0000*

0x39: *0011 1001*

若 x 在 0x30 到 0x39 之间

首先，前 28 位必须为 0000 0000 .... 0011。这是条件 1

其次，后 4 位所表示的十进制数与 10 相减必须为负数。（后四位与 0xA 相减符号位为 1）此为条件 2

1. 对于条件 1：x 向右移动 4 位即可取到前 28 位，通过与 0b11(0000 0000 .... 0011)做异或运算判断是否满足条件 1
2. 对于条件 2：x 与 0xF(0000 0000 .... 1111)做与运算即可取到后 4 位，与 0xA 做减法运算只需要与 ~0xA + 1 做加法运算（见 negate），所得结果向右移动 31 位与 1 做与运算即可得到符号位

## conditional

传入三个参数 x, y, z，使用位运算模拟三目运算符（*x ? y : z*）的操作。

构造一个掩码若 x 为 0 则为 0，否则为 111111...111

因为 C 语言中移位操作为算数移位，若右移高位补充符号位，通过这个特性可以在不使用逻辑运算的前提下构造出这个掩码 `((!!x) << 31) >> 31`

若 x 为 0，mask 为 0，~mask & z 结果为 z，mask & y 结果为 0，两者相或结果为 z

若 x 非 0，mask 为 1111..11，~mask & z 为 0，mask & y 结果为 y，两者相或结果为 y

## isLessOrEqual

传入两个参数 x, y。判断是否 x <= y

有三种情况：

1. x == y：x 与 y 做异或运算结果为 0 说明 x == y。——此为 case1

2. x 为负数，y 为正数：首先通过右移 31 位并与 1 做相与得到符号位。x 符号位为 1，y 符号位为 0 此时一定满足条件。——此为 case2

3. x 为正数，y 为负数：此时一定不满足条件 ——此取反为 case3

4. x 和 y 同号且不相等，x 与 y 做减法运算判断结果的符号位。——设符号位为 ret

综上：若 case1 为真则一定满足条件，若 case 2 为真一定满足条件，若 case3 为真仅能判断此时 x、y 为同号，为满足条件还需要 x、y 同号时相减结果为负。

最后所得表达式为 case1 | case2 | (case3 & ret)

## logicalNeg

实现一个逻辑非运算（!）逻辑非运算有一个特点只有 0 的逻辑非为 1 其他数的非均为 0

考虑补码的特点：原码、反码有 +0 -0 两个 0，但是补码的 0 是唯一的。对于补码来说 0 的相反数仍为 0。这也是补码中 0 与 其他的数的的不同（0 的相反数的符号位与数相同）

将 x 与 -x 做按位或操作，只考虑最高位符号位，只有 x 为 0 时所得结果的符号位为 0 若 x 为非 0 数字所得结果符号必为 1，将所得结果向右移动 31 位。x 为 0 时所得结果为 0，x 为非零时所得结果为 1111 1111 .... 1111，与 1 相加发生移除变成 0，而 0 变成 1。

## howManyBits

求二进制下最小需要几位表示 整数 x。

首先因为 x 可能为正数或负数，正数有效位为 1，负数有效位为 0，我们需要在不影响结果的情况下将他们规格化消除差异。

构造一个 32 位掩码（对于正数为 32 个 0，对于负数为 32 个 1），若为正数则掩码取反后相与，为负数则按位取反后与掩码相与。之后最高有效位都为 0，消除了差异，题目转换为了寻找最高位 1 所在的位置。

一开始的想法是直接寻找 x 的最高有效位是多少，但是这种方法貌似行不通。后来参照资料发现实际上是运用了一个类似二分的思想。

先将 x 分为 两个 16 位。如果发现前 16 位全为 0，说明结果一定小于 16，下一步应该去后 16 位查找。若前 16 位有 1 位为 1，则结果一定大于 16，应该去前 16 位查找。

比较巧妙的是，这个题用了位运算取判断下一步应该去哪个分支查找，通过上一步所得得有效信息对 x 进行移位。

若前 16 位全部为 0，则 $!!(x >> 16)$为 0，若前 16 位不全为 1 则此时为 0，此时将上述所得结果左移 4 为分别得 16、0，这是我们下一步需要向左移动的位数。

下一步二分是查找 8 位：如果需要向高 16 位查找，则 x 需要向左移动 16 位，对高 16 位进行二分，比较好理解。

如果需要向低 16 位查找，则 x 不需要移动，即向左移动 0 位。因为高 16 位全为 0 了，若高 24 位不为 0，则 1 肯定出现在 24 位数中低八位中的一个位置，不会对结果造成影响。

## floatScale2

简单介绍一下 IEEE754 浮点数表示法：
$$
V=(−1)^s*M*2^E
$$
其中 S 为符号位，E 为阶码，M 为尾数

对于单精度浮点数，总位数为 32 位（符号位占 1 位，阶码占 8 位，尾数占 21 位）

![](https://i.imgur.com/OnIqUpB.png)

在 IEE754 标准中，浮点数有三种状态：

1. Normalized number（规格数）
2. Denormalized number（非规格数）
3. Infinity（无穷大） 和 NaN

![](https://i.imgur.com/SVczYG0.png)

判定方式与特点：

1. 规格数：exp 不全为 0 也不全为 1，阶码的值 E = e - Bias（对于单精度 Bias 为 127、双精度 Bias 为 1023）双精度的尾数 M 位于 1 到 2 之间可以省出一位

2. exp 全为 0 则 V 为非规格数。用于表示规格数无法表示的 0 以及非常接近于 0 的数。E = 1 - Bias

3. exp 全为 1 且 frac 全为 0 时表示无穷大。exp 全为 1 且 frac 不为 0 时表示 NaN


回到题目：这个题目是给出一个 32 位无符号整数。求这个 32 位无符号所表示的单精度浮点数乘 2。

首先获取这个无符号整数所代表的单精度浮点数的各个部分。

我们需要针对这三种情况进行分类讨论。

1. 如果是规格数，显然仅需要操作 exp + 1 即原浮点数变为二倍
2. 如果是非规格数，frac 左移一位（乘 2）原浮点数变为二倍
3. 如果是无限大或 NaN，直接返回原数

## floatFloat2Int

单精度浮点数转换为整数（获取单精度浮点数的整数部分）

依然是分情况讨论：

1. 如果是无限大或 NaN，返回 0x80000000u。

2. 如果是非规格数，显然这个数要不为 0 要不非常接近于 0，整数位不可能大于 0。返回 0。

3. 如果是规格数，如果 E 小于  0，显然这个数小于 1。返回 0，如果 E 大于 31 发生溢出，返回 0x80000000u，其他情况考虑科学计数法的操作：

假设 frac 为 110 0000 0000 0000 0000 0000，实际上代表的数字是 1.110 0000 0000 0000 0000 0000，也就是目前的状态为：已经将小数点后移了 23 位。我们在根据阶码判断真正的小数点的位置（根据 E 大于或小于 23 判断我们还需左移/右移才能满足条件）

## floatPower2

给定一个 32 位有符号整数 x，求 2.0^x 单精度浮点数的二进制表示。
$$
V=(−1)^s*M*2^E
$$
参考公式，2^x 恒大于 0，所以 s 恒为 0，所以有。
$$
V=M*2^E
$$
书中有单精度浮点数可表示范围，我们直接照搬，当然这部分也不难分析

![](https://i.imgur.com/DqvXWDa.png)

由上图我们可以得知：
$$
非规格化数：V \in [2^{-149},2^{-126}) \\
规格化数：V \in [2^{-126}, 2^{127}]
$$


下面分类讨论：

1. $x<-149$：超出浮点数表示范围，返回 0

2. $x>127$：超出浮点数表示范围，返回 INF

3. $x \in [2^{-149}, 2^{-126})$内，此时 V 为非规格数，非规格数 expr 全为 0，需要表示 frac

   根据公式
   $$
   \begin{cases}
   V=2^x=M*2^E\\
   E=1-127=-126
   \end{cases}
   $$
   可得有
   $$
   2^x=M*2^{-126} \\
   M=2^{x+126}
   $$
   也就是说当 V = 2.0^x 为非规格数时，对于浮点数的三部分：e 为 0，expr 全为 0，frac 应表示 2^(x + 126) 的二进制表示（显然 frac 小于 1，忽略小数点前的 0） 

   假设 x 为 130 我们期望表示的尾数 M 为 -4，最后我们期望 frac 应为 0.001 0000 0000 0000 0000 0000，为表示这个 frac，我们应该将 1 向左移动 -4+26 位。

4. $x \in [2^{-126}, 2^{127}]$ 内，此时 V 为规格数，此时 frac 位 全为 0，需要表示 expr。按照规格数的 expr 计算方法 得 expr 为 x + 127
